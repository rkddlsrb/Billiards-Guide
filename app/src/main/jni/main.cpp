#include <jni.h>
#include <opencv2/opencv.hpp>
#include <android/asset_manager_jni.h>
#include <android/log.h>
#include <math.h>

struct point {
    int x, y;
};

struct ball {
    int x, y;
    int left_spin, right_spin;
    char color;
};

struct point finded_path[50][13]; //최종 결과
int num_find = 0; // counter
struct point find_path[13]; //임시 결과

struct point wall_point[852];
/*
const struct point wall_point[286] = {
        //당구대 아래부분 0 ~ 48
        {0,0}, {30,0},{ 60,0 },{ 90,0 },{ 120,0 },{ 150,0 },{ 180,0 },{ 210,0 },{ 240,0 },{ 270,0 },
        { 300,0 },{ 330,0 },{ 360,0 },{ 390,0 },{ 420,0 },{ 450,0 },{ 480,0 },{ 510,0 },{ 540,0 },{ 570,0 },
        { 600,0 },{ 630,0 },{ 660,0 },{ 690,0 },{ 720,0 },{ 750,0 },{ 780,0 },{ 810,0 },{ 840,0 },{ 870,0 },
        { 900,0 },{ 930,0 },{ 960,0 },{ 990,0 },{ 1020,0 },{ 1050,0 },{ 1080,0 },{ 1110,0 },{ 1140,0 },{ 1170,0 },
        { 1200,0 },{ 1230,0 },{ 1260,0 },{ 1290,0 },{ 1320,0 },{ 1350,0 },{ 1380,0 },{ 1410,0 },{ 1422,0 },
        //오른쪽 부분 49 ~ 143
        {1422,30},{ 1422,60 },{ 1422,90 },{ 1422,120 },{ 1422,150 },{ 1422,180 },{ 1422,210 },{ 1422,240 },{ 1422,270 },{ 1422,300 },
        { 1422,330 },{ 1422,360 },{ 1422,390 },{ 1422,420 },{ 1422,450 },{ 1422,480 },{ 1422,510 },{ 1422,540 },{ 1422,570 },{ 1422,600 },
        { 1422,630 },{ 1422,660 },{ 1422,690 },{ 1422,720 },{ 1422,750 },{ 1422,780 },{ 1422,810 },{ 1422,840 },{ 1422,870 },{ 1422,900 },
        { 1422,930 },{ 1422,960 },{ 1422,990 },{ 1422,1020 },{ 1422,1050 },{ 1422,1080 },{ 1422,1110 },{ 1422,1140 },{ 1422,1170 },{ 1422,1200 },
        { 1422,1230 },{ 1422,1260 },{ 1422,1290 },{ 1422,1320 },{ 1422,1350 },{ 1422,1380 },{ 1422,1410 },{ 1422,1440 },{ 1422,1470 },{ 1422,1500 },
        { 1422,1530 },{ 1422,1560 },{ 1422,1590 },{ 1422,1620 },{ 1422,1650 },{ 1422,1680 },{ 1422,1710 },{ 1422,1740 },{ 1422,1770 },{ 1422,1800 },
        { 1422,1830 },{ 1422,1860 },{ 1422,1890 },{ 1422,1920 },{ 1422,1950 },{ 1422,1980 },{ 1422,2010 },{ 1422,2040 },{ 1422,2070 },{ 1422,2100 },
        { 1422,2130 },{ 1422,2160 },{ 1422,2190 },{ 1422,2220 },{ 1422,2250 },{ 1422,2280 },{ 1422,2310 },{ 1422,2340 },{ 1422,2370 },{ 1422,2400 },
        { 1422,2430 },{ 1422,2460 },{ 1422,2490 },{ 1422,2520 },{ 1422,2550 },{ 1422,2580 },{ 1422,2610 },{ 1422,2640 },{ 1422,2670 },{ 1422,2700 },
        { 1422,2730 },{ 1422,2760 },{ 1422,2790 },{ 1422,2820 },{ 1422,2844 },
        //윗 부분 144 ~ 191
        { 0,2844 },{ 30,2844 },{ 60,2844 },{ 90,2844 },{ 120,2844 },{ 150,2844 },{ 180,2844 },{ 210,2844 },{ 240,2844 },{ 270,2844 },
        { 300,2844 },{ 330,2844 },{ 360,2844 },{ 390,2844 },{ 420,2844 },{ 450,2844 },{ 480,2844 },{ 510,2844 },{ 540,2844 },{ 570,2844 },
        { 600,2844 },{ 630,2844 },{ 660,2844 },{ 690,2844 },{ 720,2844 },{ 750,2844 },{ 780,2844 },{ 810,2844 },{ 840,2844 },{ 870,2844 },
        { 900,2844 },{ 930,2844 },{ 960,2844 },{ 990,2844 },{ 1020,2844 },{ 1050,2844 },{ 1080,2844 },{ 1110,2844 },{ 1140,2844 },{ 1170,2844 },
        { 1200,2844 },{ 1230,2844 },{ 1260,2844 },{ 1290,2844 },{ 1320,2844 },{ 1350,2844 },{ 1380,2844 },{ 1410,2844 },
        //왼쪽 부분 192 ~ 285
        { 0,30 },{ 0,60 },{ 0,90 },{ 0,120 },{ 0,150 },{ 0,180 },{ 0,210 },{ 0,240 },{ 0,270 },{ 0,300 },
        { 0,330 },{ 0,360 },{ 0,390 },{ 0,420 },{ 0,450 },{ 0,480 },{ 0,510 },{ 0,540 },{ 0,570 },{ 0,600 },
        { 0,630 },{ 0,660 },{ 0,690 },{ 0,720 },{ 0,750 },{ 0,780 },{ 0,810 },{ 0,840 },{ 0,870 },{ 0,900 },
        { 0,930 },{ 0,960 },{ 0,990 },{ 0,1020 },{ 0,1050 },{ 0,1080 },{ 0,1110 },{ 0,1140 },{ 0,1170 },{ 0,1200 },
        { 0,1230 },{ 0,1260 },{ 0,1290 },{ 0,1320 },{ 0,1350 },{ 0,1380 },{ 0,1410 },{ 0,1440 },{ 0,1470 },{ 0,1500 },
        { 0,1530 },{ 0,1560 },{ 0,1590 },{ 0,1620 },{ 0,1650 },{ 0,1680 },{ 0,1710 },{ 0,1740 },{ 0,1770 },{ 0,1800 },
        { 0,1830 },{ 0,1860 },{ 0,1890 },{ 0,1920 },{ 0,1950 },{ 0,1980 },{ 0,2010 },{ 0,2040 },{ 0,2070 },{ 0,2100 },
        { 0,2130 },{ 0,2160 },{ 0,2190 },{ 0,2220 },{ 0,2250 },{ 0,2280 },{ 0,2310 },{ 0,2340 },{ 0,2370 },{ 0,2400 },
        { 0,2430 },{ 0,2460 },{ 0,2490 },{ 0,2520 },{ 0,2550 },{ 0,2580 },{ 0,2610 },{ 0,2640 },{ 0,2670 },{ 0,2700 },
        { 0,2730 },{ 0,2760 },{ 0,2790 },{ 0,2820 }
};
*/
struct point database[400][13] = {
        //3쿠션 난구풀이 케이스100 - 16개
        {{520,2271},{920,2427},{1326,2811}, {520,2271},{906,2444},{970,2844},{1422,2104},{423,0},{0,500},{1422,2657},{1326,2777},{-1,-1},{0,0}},
        {{358,2073},{213,2111},{593,2777}, {358,2073},{231,2159},{255,2844},{1422,1714},{0,120},{80,0},{1422,1566},{644,2770},{-1,-1},{0,0}},
        {{332,1943},{867,2443},{1321,2804}, {332,1943},{832,2461},{1028,2844},{1422,1836},{478,0},{0,515},{1422,2618},{1289,2765},{-1,-1},{0,0}},
        {{1170,461},{1196,597},{1366,964}, {1170,461},{1226,577},{1422,704},{0,2174},{513,2844},{1386,1000},{-1,-1},{0,0},{0,0},{0,0}},
        {{625,2247},{553,2229},{264,2579}, {625,2247},{553,2279},{232,2844},{0,2636},{1422,772},{890,0},{0,2172},{207,2844},{282,2626},{-1,-1}},
        {{1296,2618},{1132,2810},{85,2743}, {1296,2618},{1121,2768},{0,1404},{782,0},{1422,633},{75,2711},{-1,-1},{0,0},{0,0},{0,0}},
        {{946,686},{31,2111},{107,133}, {946,686},{89,2111},{560,2844},{1422,1911},{242,0},{139,158},{-1,-1},{0,0},{0,0},{0,0}},
        {{748,426},{322,701},{1366,1978}, {748,426},{329,641},{0,489},{959,0},{1422,286},{0,1708},{785,2844},{1351,2012},{-1,-1},{0,0}},
        {{1334,2520},{1230,2801},{80,2804}, {1334,2520},{1200,2770},{1119,2839},{0,1700},{990,0},{1422,439},{15,2747},{53,2797},{-1,-1},{0,0}},
        {{532,2413},{964,2489},{424,2805}, {532,2413},{916,2445},{1422,1093},{1272,9},{0,1781},{372,2844},{396,2821},{-1,-1},{0,0},{0,0}},
        {{779,1096},{287,2205},{445,2792}, {779,1096},{258,2171},{0,2292},{1422,2492},{0,2646},{1422,2726},{483,2796},{-1,-1},{0,0},{0,0}},
        {{643,2357},{365,2374},{1317,2796}, {643,2357},{386,2414},{0,2696},{165,2844},{1422,1866},{0,205},{200,0},{1422,2635},{1326,2753},{-1,-1}},
        {{1245,2082},{1191,2382},{409,2592}, {1245,2082},{1218,2351},{1422,2473},{577,2844},{0,2673},{368,2605},{-1,-1},{0,0},{0,0},{0,0}},
        {{1162,481},{1081,853},{1314,2801}, {1162,481},{1042,843},{0,1986},{752,2844},{1422,1810},{642,0},{0,686},{1228,2844},{1276,2796},{-1,-1}},
        {{733,2705},{642,2705},{147,124}, {733,2705},{676,2672},{0,1477},{781,0},{1422,2053},{1204,2844},{0,229},{114,167},{-1,-1},{0,0}},
        {{745,2166},{130,2121},{770,2456}, {745,2166},{155,2171},{0,2276},{1185,2844},{1422,2701},{820,2486},{-1,-1},{0,0},{0,0},{0,0}},

        //당구강좌 더레슨 시즌1 - 84개
        {{406,1814},{993,1831},{176,331}, {406,1814},{966,1794},{1422,1454},{200,0},{0,180},{133,291},{-1,-1},{0,0},{0,0},{0,0}},
        {{189,393},{1085,879},{207,290}, {189,393},{1075,836},{1422,726},{200,0},{0,136},{167,268},{-1,-1},{0,0},{0,0},{0,0}},
        {{766,1377},{1333,1287},{1333,2744}, {766,1377},{1333,1257},{1422,1147},{683,0},{0,681},{1422,2727},{1353,2794},{-1,-1},{0,0},{0,0}},
        {{782,1383},{1339,1304},{1032,2740}, {782,1383},{1325,1254},{1422,958},{1067,0},{0,1222},{996,2715},{-1,-1},{0,0},{0,0},{0,0}},
        {{757,1136},{1346,1168},{1378,2197}, {757,1136},{1346,1140},{1422,1079},{546,0},{0,440},{1371,2154},{-1,-1},{0,0},{0,0},{0,0}},
        {{714,772},{1382,1058},{157,454}, {714,772},{1396,1011},{1422,1000},{442,0},{0,308},{128,433},{-1,-1},{0,0},{0,0},{0,0}},
        {{488,671},{1366,352},{159,1589}, {488,671},{1344,326},{1422,238},{1300,0},{0,1349},{137,1552},{-1,-1},{0,0},{0,0},{0,0}},
        {{273,258},{657,254},{1369,366}, {273,258},{669,293},{1422,981},{415,2844},{0,2397},{1346,420},{-1,-1},{0,0},{0,0},{0,0}},
        {{724,1573},{80,2133},{708,2757}, {724,1573},{72,2097},{20,2125},{1422,2637},{888,2844},{740,2753},{-1,-1},{0,0},{0,0},{0,0}},
        {{904,634},{741,605},{1129,2663}, {904,634},{754,638},{0,1309},{1422,2655},{1308,2844},{1158,2676},{-1,-1},{0,0},{0,0},{0,0}},

        {{530,691},{713,2131},{706,694}, {530,691},{743,2124},{1422,2707},{1276,2844},{0,1654},{706,741},{-1,-1},{0,0},{0,0},{0,0}},
        {{1357,418},{667,468},{517,1247}, {1357,418},{678,508},{0,1183},{1135,2844},{1422,2536},{525,1283},{-1,-1},{0,0},{0,0},{0,0}},
        {{132,908},{571,1047},{1078,790}, {132,908},{550,1086},{1422,1961},{832,2844},{0,2140},{1078,836},{-1,-1},{0,0},{0,0},{0,0}},
        {{703,461},{1089,636},{785,86}, {703,461},{1085,679},{1422,1626},{1035,2844},{0,1433},{767,118},{-1,-1},{0,0},{0,0},{0,0}},
        {{859,189},{987,382},{848,64}, {859,189},{896,389},{0,2523},{107,2834},{1422,960},{907,0},{870,97},{-1,-1},{0,0},{0,0}},
        {{361,1501},{1030,2201},{480,51}, {361,1501},{1046,2166},{1422,2270},{215,2844},{0,2674},{1422,1308},{484,85},{-1,-1},{0,0},{0,0}},
        {{432,118},{450,36},{871,2104}, {432,118},{485,65},{660,0},{1422,222},{0,1293},{860,2072},{-1,-1},{0,0},{0,0},{0,0}},
        {{1383,2155},{891,2313},{295,459}, {1383,2155},{908,2351},{512,2844},{0,2509},{1422,1059},{591,0},{283,413},{-1,-1},{0,0},{0,0}},
        {{956,83},{769,192},{1130,1492}, {956,83},{773,157},{513,0},{0,144},{1422,1214},{1147,1474},{-1,-1},{0,0},{0,0},{0,0}},
        {{234,351},{130,481},{853,2554}, {234,351},{153,508},{0,1285},{184,2844},{1273,0},{1422,524},{976,2844},{873,2593},{-1,-1},{0,0}},

        {{513,914},{370,1747},{123,167}, {513,914},{336,1751},{0,1984},{513,2844},{1422,1997},{146,207},{-1,-1},{0,0},{0,0},{0,0}},
        {{678,843},{396,1747},{121,147}, {678,843},{428,1761},{950,2844},{1422,2397},{0,304},{100,186},{-1,-1},{0,0},{0,0},{0,0}},
        {{607,583},{1271,1651},{885,1443}, {607,583},{1285,1618},{1422,1626},{325,2844},{0,2522},{857,1483},{-1,-1},{0,0},{0,0},{0,0}},
        {{942,1036},{889,1776},{260,2518}, {942,1036},{928,1776},{1422,2418},{1228,2844},{0,1293},{778,0},{1422,629},{285,2479},{-1,-1},{0,0}},
        {{725,1575},{77,2127},{707,2752}, {725,1575},{100,2123},{0,2097},{1422,2634},{896,2844},{733,2745},{-1,-1},{0,0},{0,0},{0,0}},
        {{753,1966},{61,2489},{1026,2804}, {753,1966},{69,2462},{0,2481},{1422,2516},{0,2628},{1422,2766},{1061,2804},{-1,-1},{0,0},{0,0}},
        {{360,689},{248,1817},{72,69}, {360,689},{224,1805},{0,1957},{600,2844},{1422,1969},{92,113},{-1,-1},{0,0},{0,0},{0,0}},
        {{500,426},{408,755},{79,101}, {500,426},{383,734},{0,1217},{816,2844},{1422,2126},{104,138},{-1,-1},{0,0},{0,0},{0,0}},
        {{723,701},{519,1701},{365,35}, {723,701},{480,1689},{0,2193},{273,2844},{1422,1658},{380,58},{-1,-1},{0,0},{0,0},{0,0}},
        {{307,751},{373,1751},{46,724}, {307,751},{342,1758},{0,2351},{161,2844},{1422,1185},{734,0},{76,697},{-1,-1},{0,0},{0,0}},

        {{716,674},{430,1734},{376,47}, {716,674},{400,1741},{0,1967},{873,2844},{1422,2377},{0,531},{330,64},{-1,-1},{0,0},{0,0}},
        {{1057,1151},{660,1922},{57,693}, {1057,1151},{632,1918},{0,2147},{807,2844},{1422,2390},{60,729},{-1,-1},{0,0},{0,0},{0,0}},
        {{785,1051},{960,1290},{53,165}, {785,1051},{0,2215},{367,2844},{1422,2165},{125,0},{67,133},{-1,-1},{0,0},{0,0},{0,0}},
        {{300,565},{342,854},{1214,2486}, {300,565},{321,876},{0,1193},{1246,2844},{1422,2658},{1246,2508},{-1,-1},{0,0},{0,0},{0,0}},
        {{863,1652},{574,2082},{1163,2293}, {863,1652},{244,2075},{14,2386},{855,2844},{1422,2545},{1200,2323},{-1,-1},{0,0},{0,0},{0,0}},
        {{311,674},{615,2639},{100,139}, {311,674},{646,2631},{853,2844},{1422,2204},{161,0},{119,97},{-1,-1},{0,0},{0,0},{0,0}},
        {{392,677},{932,2721},{144,129}, {392,677},{960,2693},{1100,2844},{1422,2409},{0,133},{76,0},{132,109},{-1,-1},{0,0},{0,0}},
        {{420,1184},{612,2705},{158,746}, {420,1184},{641,2696},{816,2844},{1422,2451},{0,946},{100,784},{-1,-1},{0,0},{0,0},{0,0}},
        {{1113,2388},{778,2796},{52,440}, {1113,2388},{804,2796},{860,2844},{1422,1988},{408,0},{69,401},{-1,-1},{0,0},{0,0},{0,0}},
        {{500,569},{168,2137},{68,296}, {500,569},{200,2142},{613,2844},{1422,1923},{281,0},{63,264},{-1,-1},{0,0},{0,0},{0,0}},

        {{406,2387},{680,2777},{226,1417}, {406,2387},{710,2754},{916,2844},{1422,2637},{0,1547},{163,1434},{-1,-1},{0,0},{0,0},{0,0}},
        {{1178,2397},{1057,2647},{139,1104}, {1178,2397},{1089,2647},{1289,2844},{1422,2697},{0,1290},{117,1136},{-1,-1},{0,0},{0,0},{0,0}},
        {{532,704},{717,2140},{710,701}, {532,704},{750,2126},{1422,2715},{1310,2844},{0,1647},{682,726},{-1,-1},{0,0},{0,0},{0,0}},
        {{729,63},{966,1208},{1377,330}, {729,63},{992,1201},{1422,1464},{563,2844},{0,2290},{1351,375},{-1,-1},{0,0},{0,0},{0,0}},
        {{1357,316},{1153,270},{1088,1777}, {1357,316},{1146,312},{0,1454},{796,2844},{1422,2197},{1119,1812},{-1,-1},{0,0},{0,0},{0,0}},
        {{1093,1737},{880,1681},{713,1324}, {1093,1737},{883,1717},{0,2271},{503,2844},{1422,2131},{756,1341},{-1,-1},{0,0},{0,0},{0,0}},
        {{760,976},{1214,768},{239,1090}, {760,976},{1196,740},{1410,465},{1032,0},{0,818},{210,1054},{-1,-1},{0,0},{0,0},{0,0}},
        {{330,1047},{1226,1012},{288,1251}, {330,1047},{1207,981},{1422,693},{1038,0},{0,977},{253,1235},{-1,-1},{0,0},{0,0},{0,0}},
        {{330,1824},{1100,1781},{615,1362}, {330,1824},{1084,1754},{1422,1362},{576,0},{0,562},{580,1327},{-1,-1},{0,0},{0,0},{0,0}},
        {{638,1516},{1215,1974},{626,2181}, {638,1516},{1230,1947},{1422,1997},{103,2844},{0,2735},{592,2212},{-1,-1},{0,0},{0,0},{0,0}},

        {{596,2204},{800,2024},{1165,1470}, {596,2204},{815,2054},{1422,2174},{434,2844},{0,2616},{1119,1512},{-1,-1},{0,0},{0,0},{0,0}},
        {{1396,1451},{1153,1339},{1384,2489}, {1396,1451},{1165,1312},{780,0},{0,1051},{988,2844},{1342,2493},{-1,-1},{0,0},{0,0},{0,0}},
        {{973,97},{1070,74},{1343,247}, {973,97},{1066,137},{1422,1307},{453,2844},{0,2327},{1240,0},{1340,194},{-1,-1},{0,0},{0,0}},
        {{200,1429},{346,1426},{100,2654}, {200,1429},{350,1476},{700,2844},{1422,1508},{1003,0},{100,2583},{-1,-1},{0,0},{0,0},{0,0}},
        {{750,758},{896,811},{875,258}, {750,758},{896,872},{1221,2844},{1422,2347},{960,0},{889,218},{-1,-1},{0,0},{0,0},{0,0}},
        {{285,922},{692,2740},{64,608}, {285,922},{707,2715},{1128,2844},{1422,2565},{367,0},{89,576},{-1,-1},{0,0},{0,0},{0,0}},
        {{307,1689},{529,1464},{1370,208}, {307,1689},{537,1515},{1003,2844},{1422,2249},{726,0},{0,1700},{285,2844},{1351,226},{-1,-1},{0,0}},
        {{392,2127},{896,2770},{169,2589}, {392,2127},{900,2724},{1422,1493},{1011,0},{0,2524},{92,2844},{153,2643},{-1,-1},{0,0},{0,0}},
        {{1324,473},{1392,717},{1356,2617}, {1324,473},{1372,741},{716,2844},{0,1581},{412,0},{1422,2421},{1368,2569},{-1,-1},{0,0},{0,0}},
        {{1316,305},{1387,205},{487,1455}, {1316,305},{1391,267},{1420,430},{825,2844},{0,413},{112,0},{483,1405},{-1,-1},{0,0},{0,0}},

        {{873,874},{1053,2714},{1360,204}, {873,874},{1079,2071},{1223,2844},{1422,2551},{700,0},{0,1442},{350,2844},{1353,259},{-1,-1},{0,0}},
        {{328,2361},{517,2018},{67,2626}, {328,2361},{528,2051},{846,2844},{1422,1676},{1050,0},{75,2593},{-1,-1},{0,0},{0,0},{0,0}},
        {{103,2533},{292,2261},{85,2351}, {103,2533},{292,2318},{485,2844},{1422,986},{1200,0},{228,2844},{89,2408},{-1,-1},{0,0},{0,0}},
        {{366,1927},{903,1408},{66,2634}, {366,1927},{903,1478},{1248,2844},{1422,2408},{900,0},{77,2575},{-1,-1},{0,0},{0,0},{0,0}},
        {{65,251},{246,608},{442,712}, {65,251},{246,566},{520,0},{1422,1077},{900,2844},{0,812},{196,0},{426,670},{-1,-1},{0,0}},
        {{164,673},{288,1897},{516,913}, {164,673},{276,1857},{172,2853},{0,2149},{320,0},{500,877},{-1,-1},{0,0},{0,0},{0,0}},
        {{396,813},{440,1821},{160,929}, {396,813},{424,1829},{268,2844},{0,413},{60,0},{156,881},{-1,-1},{0,0},{0,0},{0,0}},
        {{308,996},{600,2746},{358,421}, {308,996},{575,2734},{545,2844},{0,1580},{229,0},{337,367},{-1,-1},{0,0},{0,0},{0,0}},
        {{395,1009},{747,2601},{160,161}, {395,1009},{730,2588},{700,2844},{0,744},{70,0},{143,109},{-1,-1},{0,0},{0,0},{0,0}},
        {{568,2087},{1059,160},{1154,2387}, {568,2087},{1054,187},{1063,0},{1422,1832},{1263,2844},{1172,2437},{-1,-1},{0,0},{0,0},{0,0}},

        {{1003,2654},{1363,1571},{63,1471}, {1003,2654},{1366,1627},{1422,1604},{693,0},{0,1241},{66,1451},{-1,-1},{0,0},{0,0},{0,0}},
        {{671,1215},{910,1926},{1328,154}, {671,1215},{900,1951},{957,2844},{1422,358},{1360,0},{1346,129},{-1,-1},{0,0},{0,0},{0,0}},
        {{978,693},{1221,715},{1339,2651}, {978,693},{1214,761},{1417,1372},{896,2844},{0,1018},{283,0},{1332,2622},{-1,-1},{0,0},{0,0}},
        {{62,667},{162,141},{1240,2645}, {62,667},{185,189},{563,0},{1422,378},{292,2844},{0,2341},{618,0},{1422,1908},{1240,2601},{-1,-1}},
        {{815,397},{1011,689},{1192,2308}, {815,397},{1011,643},{1250,0},{1422,324},{626,2844},{0,1370},{320,0},{1173,2254},{-1,-1},{0,0}},
        {{1004,805},{1280,1045},{1284,529}, {1004,805},{1276,1001},{1420,597},{1248,0},{356,2844},{0,1869},{1108,0},{1422,393},{1300,525},{-1,-1}},
        {{100,113},{192,433},{884,1921}, {100,113},{184,449},{0,1221},{1168,2844},{1422,2569},{912,1937},{-1,-1},{0,0},{0,0},{0,0}},
        {{391,1301},{11041,2417},{1045,401}, {391,1301},{1033,2438},{1141,2844},{1422,1334},{1170,0},{1062,367},{-1,-1},{0,0},{0,0},{0,0}},
        {{365,1183},{1056,2457},{52,2170}, {365,1183},{1039,2453},{1191,2844},{1422,1266},{1178,0},{321,2844},{56,2214},{-1,-1},{0,0},{0,0}},
        {{1218,682},{1350,1332},{259,169}, {1218,682},{1372,1305},{1422,1455},{886,2844},{0,937},{250,201},{-1,-1},{0,0},{0,0},{0,0}},

        {{1276,301},{1333,1184},{63,511}, {1276,301},{1396,1181},{1422,1544},{1090,2844},{233,0},{73,464},{-1,-1},{0,0},{0,0},{0,0}},
        {{232,2211},{632,2622},{1167,776}, {232,2211},{614,2654},{685,2844},{1422,493},{1321,0},{1171,715},{-1,-1},{0,0},{0,0},{0,0}},
        {{375,990},{860,2418},{278,2454}, {375,990},{860,2372},{1422,2508},{696,2844},{0,2572},{271,2443},{-1,-1},{0,0},{0,0},{0,0}},
        {{281,1945},{363,1415},{103,2627}, {281,1945},{348,1412},{240,0},{0,2282},{59,2844},{85,2652},{-1,-1},{0,0},{0,0},{0,0}},
};

double calcDistance(point p1, point p2, ball b1) { // b1-기준공, p1-기준좌표, b2-계산할 공 좌표
    float a = ((float)p2.y - (float)p1.y) / ((float)p2.x - (float)p1.x);

    return fabsf(a*((float)b1.x - (float)p2.x) - (float)b1.y + (float)p2.y) / sqrt(a*a + 1);
}

bool ball_collision(point s, point e, ball b) {
    if (s.x > e.x && s.y > e.y) { //s가 오른쪽 위
        if (calcDistance(s, e, b) < 61.5 && e.x - 61.5 < b.x && b.x < s.x + 61.5 && e.y - 61.5 < b.y && b.y < s.y + 61.5)
            return true;
    }
    else if (s.x < e.x && s.y > e.y) { //s가 왼쪽 위
        if (calcDistance(s, e, b) < 61.5 && s.x - 61.5 < b.x && b.x < e.x + 61.5 && e.y - 61.5 < b.y && b.y < s.y + 61.5)
            return true;
    }
    else if (s.x > e.x && s.y < e.y) { //s가 오른쪽 아래
        if (calcDistance(s, e, b) < 61.5 && e.x - 61.5 < b.x && b.x < s.x + 61.5 && s.y - 61.5 < b.y && b.y < e.y + 61.5)
            return true;
    }
    else { //s가 왼쪽 아래
        if (calcDistance(s, e, b) < 61.5 && s.x - 61.5 < b.x && b.x < e.x + 61.5 && s.y - 61.5 < b.y && b.y < e.y + 61.5)
            return true;
    }

    return false;
}

point calcPoint(point p1, point p2, int left_spin, int right_spin) {
    //두 점이 p2가 존재하는 면과 이루는 각도 계산, 반사각이 도달하는 점 return
    point p3;
    double inc_ang,ref_ang; //입사각, 기준점과의 반사각

    if (p2.x == 0) { //왼쪽 벽
        inc_ang = (57.2957)*asin(p1.x / sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2)));

        if (p1.y < p2.y) { //시계방향
            ref_ang = (57.2957)*asin(1422 / sqrt(pow(1422 - p2.x, 2) + pow(2844 - p2.y, 2)));
            if (ref_ang < inc_ang) { //오른쪽 벽으로 반사됨
                p3.x = 1422;
                p3.y = p2.y + (int)(((double)(p2.y - p1.y) / (p1.x))*(1422));
                if (right_spin > 0) { // p3.y값 증가
                    int val = p3.y - p2.y;
                    if (p3.y + val < 2844) { // 그대로 오른쪽 벽으로 반사
                        p3.y = p3.y + val;
                    }
                    else { // 위쪽 벽으로 반사
                        p3.x = 1422 - (p3.y + val - 2844);
                        p3.y = 2844;
                    }
                }
            }
            else if (ref_ang >= inc_ang) { //위쪽 벽으로 반사됨
                p3.x = (int)(((double)(p1.x) / (p2.y - p1.y)) * (2844 - p2.y));
                p3.y = 2844;
                if (right_spin > 0) { // p3.x값 감소
                    p3.x /= 2;
                }
            }
        }
        else if(p1.y > p2.y){ //반시계방향
            ref_ang = (57.2957)*asin(1422 / sqrt(pow(1422 - p2.x, 2) + pow(p2.y, 2)));
            if (ref_ang < inc_ang) { //오른쪽 벽으로 반사됨
                p3.x = 1422;
                p3.y = p2.y - (int)(((double)(p1.y - p2.y) / (p1.x))*(1422));
                if (left_spin > 0) { // p3.y값 감소
                    int val = p2.y - p3.y;
                    if (p3.y - val > 0) { // 그대로 오른쪽 벽으로 반사
                        p3.y = p3.y - val;
                    }
                    else { // 아래쪽 벽으로 반사
                        p3.x = 1422 - (val - p3.y);
                        p3.y = 0;
                    }
                }
            }
            else if (ref_ang >= inc_ang) { //아래쪽 벽으로 반사됨
                p3.x = (int)(((double)(p1.x) / (p1.y - p2.y)) * (p2.y));
                p3.y = 0;
                if (left_spin > 0) { // p3.x값 감소
                    p3.x /= 2;
                }
            }
        }
        else {
            p3.x = 0;
            p3.y = 0;
        }
    }
    else if (p2.y == 2844) { // 위쪽 벽
        inc_ang = (57.2957)*asin((2844 - p1.y) / sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2)));

        if (p1.x < p2.x) { //시계방향
            ref_ang = (57.2957)*asin(2844 / sqrt(pow(1422 - p2.x, 2) + pow(p2.y, 2)));
            if (ref_ang < inc_ang) { // 아래 벽으로 반사됨
                p3.x = p2.x + (int)(((double)(p2.x - p1.x) / (2844 - p1.y)) * 2844);
                p3.y = 0;
                if (right_spin > 0) {
                    int val = p3.x - p2.x;
                    if (p3.x + val < 1422) { // 그대로 아래쪽 벽
                        p3.x = p3.x + val;
                    }
                    else { // 오른쪽 벽으로 반사
                        p3.y = (p3.x + val - 1422);
                        p3.x = 1422;
                    }
                }
            }
            else if (ref_ang >= inc_ang) { // 오른쪽 벽으로 반사됨
                p3.x = 1422;
                p3.y = 2844 - (int)(((double)(2844 - p1.y) / (p2.x - p1.x))*(1422 - p2.x));
                if (right_spin > 0) {
                    p3.y = p3.y + ((2844 - p3.y) / 2);
                }
            }
        }
        else if(p1.x > p2.x){ //반시계방향
            ref_ang = (57.2957)*asin(2844 / sqrt(pow(p2.x, 2) + pow(p2.y, 2)));
            if (ref_ang < inc_ang) { // 아래 벽으로 반사됨
                p3.x = p2.x - (int)(((double)(p1.x - p2.x) / (2844 - p1.y)) * 2844);
                p3.y = 0;
                if (left_spin > 0) {
                    int val = p2.x - p3.x;
                    if (p3.x - val > 0) { // 그대로 아래 벽
                        p3.x = p3.x - val;
                    }
                    else{ // 왼쪽 벽으로 반사됨
                        p3.y = val - p3.x;
                        p3.x = 0;
                    }
                }
            }
            else if (ref_ang >= inc_ang) { // 왼쪽 벽으로 반사됨
                p3.x = 0;
                p3.y = 2844 - (int)(((double)(2844 - p1.y) / (p1.x - p2.x))*(p2.x));
                if (left_spin > 0) {
                    p3.y = p3.y + ((2844 - p3.y) / 2);
                }
            }
        }
        else {
            p3.x = 0;
            p3.y = 0;
        }
    }
    else if (p2.x == 1422) { // 오른쪽 벽
        inc_ang = (57.2957)*asin((1422 - p1.x) / sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2)));

        if (p1.y > p2.y) { //시계방향
            ref_ang = (57.2957)*asin((1422) / sqrt(pow(p2.x, 2) + pow(p2.y, 2)));
            if (ref_ang < inc_ang) { // 왼쪽 벽으로 반사됨
                p3.x = 0;
                p3.y = p2.y - (int)(((double)(p1.y - p2.y) / (1422 - p1.x))*(1422));
                if (right_spin > 0) {
                    int val = p2.y - p3.y;
                    if (p3.y - val > 0) { //그대로 왼쪽벽
                        p3.y = p3.y - val;
                    }
                    else { //아래쪽 벽
                        p3.x = val - p3.y;
                        p3.y = 0;
                    }
                }
            }
            else if (ref_ang >= inc_ang) { // 아래쪽 벽으로 반사됨
                p3.x = 1422 - (int)(((double)(1422 - p1.x) / (p1.y - p2.y))*(p2.y));
                p3.y = 0;
                if (right_spin > 0) {
                    p3.x = p3.x + ((1422 - p3.x) / 2);
                }
            }
        }
        else if(p1.y < p2.y){ //반시계방향
            ref_ang = (57.2957)*asin((1422) / sqrt(pow(p2.x, 2) + pow(2844 - p2.y, 2)));
            if (ref_ang < inc_ang) { // 왼쪽 벽으로 반사됨
                p3.x = 0;
                p3.y = p2.y + (int)(((double)(p2.y - p1.y) / (1422 - p1.x))*(1422));
                if (left_spin > 0) {
                    int val = p3.y - p2.y;
                    if (p3.y + val < 2844) { //그대로 왼쪽 벽
                        p3.y = p3.y + val;
                    }
                    else { //위쪽 벽
                        p3.x = val - (2844 - p3.y);
                        p3.y = 2844;
                    }
                }
            }
            else if (ref_ang >= inc_ang) { // 위쪽 벽으로 반사됨
                p3.x = 1422 - (int)(((double)(1422 - p1.x) / (p2.y - p1.y))*(2844 - p2.y));
                p3.y = 2844;
                if (left_spin > 0) {
                    p3.x = p3.x + ((1422 - p3.x) / 2);
                }
            }
        }
        else {
            p3.x = 0;
            p3.y = 0;
        }
    }
    else if (p2.y == 0) { //아래 벽
        inc_ang = (57.2957)*asin(p1.y / sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2)));

        if (p1.x > p2.x) { //시계방향
            ref_ang = (57.2957)*asin(2844 / sqrt(pow(p2.x, 2) + pow(2844 - p2.y, 2)));
            if (ref_ang < inc_ang) { // 위쪽 벽으로 반사됨
                p3.x = p2.x - (int)(((double)(p1.x - p2.x) / p1.y) * 2844);
                p3.y = 2844;
                if (right_spin > 0) {
                    int val = p2.x - p3.x;
                    if (p3.x - val > 0) { // 그대로 위쪽 벽
                        p3.x = p3.x - val;
                    }
                    else { // 왼쪽 벽
                        p3.y = 2844 - (val - p3.x);
                        p3.x = 0;
                    }
                }
            }
            else if (ref_ang >= inc_ang) { // 왼쪽 벽으로 반사됨
                p3.x = 0;
                p3.y = (int)(((double)p1.y / (p1.x - p2.x))*p2.x);
                if (right_spin > 0) {
                    p3.y /= 2;
                }
            }
        }
        else if(p1.x < p2.x){ //반시계방향
            ref_ang = (57.2957)*asin(2844 / sqrt(pow(1422 - p2.x, 2) + pow(2844 - p2.y, 2)));
            if (ref_ang < inc_ang) { // 위쪽 벽으로 반사됨
                p3.x = p2.x + (int)(((double)(p2.x - p1.x) / p1.y) * 2844);
                p3.y = 2844;
                if (left_spin > 0) {
                    int val = p3.x - p2.x;
                    if (p3.x + val < 1422) { //그대로 위쪽
                        p3.x = p3.x + val;
                    }
                    else { //오른쪽
                        p3.y = val - (1422 - p3.x);
                        p3.x = 1422;
                    }
                }
            }
            else if (ref_ang >= inc_ang) { // 오른쪽 벽으로 반사됨
                p3.x = 1422;
                p3.y = (int)(((double)p1.y / (p2.x - p1.x))*(1422 - p2.x));
                if (left_spin > 0) {
                    p3.y /= 2;
                }
            }
        }
        else {
            p3.x = 0;
            p3.y = 0;
        }
    }

    return p3;
}

using namespace cv;
using namespace std;

extern "C"{

JNIEXPORT jintArray JNICALL
Java_com_example_kig_billiardsguide_imageanalysis_ImageBinarize(JNIEnv *env, jobject, jlong addrInputImage, jlong addrOutputImage, jlong addrPoolImage, jlong addrYbImage, jlong addrWbImage, jlong addrRbImage, jint hitball,
                                                                jlong addrOutputImage1, jlong addrOutputImage2, jlong addrOutputImage3, jlong addrOutputImage4, jlong addrOutputImage5, jlong addrOutputImage6, jlong addrOutputImage7,
                                                                jlong addrOutputImage8, jlong addrOutputImage9){
    Mat &img_input = *(Mat *) addrInputImage;
    Mat &img_output = *(Mat *) addrOutputImage;
    Mat &img_output1 = *(Mat *) addrOutputImage1;
    Mat &img_output2 = *(Mat *) addrOutputImage2;
    Mat &img_output3 = *(Mat *) addrOutputImage3;
    Mat &img_output4 = *(Mat *) addrOutputImage4;
    Mat &img_output5 = *(Mat *) addrOutputImage5;
    Mat &img_output6 = *(Mat *) addrOutputImage6;
    Mat &img_output7 = *(Mat *) addrOutputImage7;
    Mat &img_output8 = *(Mat *) addrOutputImage8;
    Mat &img_output9 = *(Mat *) addrOutputImage9;
    Mat &img_pool = *(Mat *) addrPoolImage;
    Mat &img_yb = *(Mat *) addrYbImage;
    Mat &img_wb = *(Mat *) addrWbImage;
    Mat &img_rb = *(Mat *) addrRbImage;
    jintArray result;
    result = (*env).NewIntArray(31);

    Mat img_hsv;
    Mat img_result, img_transform;

    resize(img_input, img_input, Size(1526,2948), 0, 0, INTER_LINEAR);

    img_result = img_input.clone();

    int infor[31];

    cvtColor(img_input, img_hsv, COLOR_RGB2HSV);

    //지정한 HSV 범위를 이용하여 이미지를 이진화
    Mat img_mask1;
    inRange(img_hsv, Scalar(90, 100, 100), Scalar(130, 255, 255), img_mask1);

    //morphological opening 작은 점들을 제거
    erode(img_mask1, img_mask1, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
    dilate(img_mask1, img_mask1, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));

    //morphological closing 영역의 구멍 메우기
    dilate(img_mask1, img_mask1, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
    erode(img_mask1, img_mask1, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));

    /*
    //라벨링
    Mat img_labels, stats, centroids;
    int numOfLables = connectedComponentsWithStats(img_mask1, img_labels, stats, centroids, 8, CV_32S);

    //영역박스 그리기
    int max = -1, idx = 0;
    for (int j = 1; j < numOfLables; j++) {
        int area = stats.at<int>(j, CC_STAT_AREA);
        if (max < area) {
            max = area;
            idx = j;
        }
    }

    int left = stats.at<int>(idx, CC_STAT_LEFT);
    int top = stats.at<int>(idx, CC_STAT_TOP);
    int width = stats.at<int>(idx, CC_STAT_WIDTH);
    int height = stats.at<int>(idx, CC_STAT_HEIGHT);

    rectangle(img_input, Point(left, top), Point(left + width, top + height), Scalar(0, 0, 255), 1);
     */

    //img_output = img_mask1;

    /*
    int nThreshold = 5;
    int ratio = 3;
    int kernelSize = 3;
    Mat img_gray, img_canny;
    //cvtColor(m_image, img_gray, COLOR_BGR2GRAY);
    //blur(img_gray, img_canny, Size(3,3));
    //blur(img_mask1, img_canny, Size(3,3));
    GaussianBlur(img_mask1, img_canny, Size(3,3), 0);
    Canny(img_canny, img_canny, nThreshold, nThreshold*ratio, kernelSize);

    //img_output = img_canny;

    Mat kernel = getStructuringElement(MORPH_ELLIPSE, Size(11,11));
    Mat morph;
    morphologyEx(img_canny, morph, CV_MOP_CLOSE, kernel);

    //img_output = morph;

    size_t idx, i;
    vector<vector<Point>> contours;
    vector<Vec4i> hierarchy;
    findContours(morph, contours, hierarchy, CV_RETR_CCOMP, CV_CHAIN_APPROX_SIMPLE, Point(0,0));

    Mat contours_img;
    cvtColor(img_canny, contours_img, CV_GRAY2BGR);
    for(idx=0; idx < contours.size(); idx++){
        RotatedRect rect = minAreaRect(contours[idx]);
        double areaRatio = abs(contourArea(contours[idx])) / (rect.size.width * rect.size.height);
        drawContours(contours_img, contours, -1, Scalar(255, 0, 0), 2);
    }

    //img_output = contours_img;

    vector<Point> poly;

    Mat poly_img, ractangle_img;
    cvtColor(img_canny, poly_img, CV_GRAY2BGR);
    cvtColor(img_canny, ractangle_img, CV_GRAY2BGR);

    for(idx=0; idx<contours.size(); idx++){
        approxPolyDP(contours[idx], poly, 1, true);
        for(i=0;i<poly.size(); i++){
            line(poly_img, poly[i], poly[(i+1) % poly.size()], Scalar(0, 255, 0), 2);

            if(poly.size() == 4){
                line(ractangle_img, poly[i], poly[(i+1) % poly.size()], Scalar(0, 0, 255), 2);
            }
        }
    }

    //img_output = poly_img;
     */

    //contour를 찾는다.
    vector<vector<Point>> contours;
    findContours(img_mask1, contours, RETR_LIST, CHAIN_APPROX_SIMPLE);

    //contour를 근사화한다.
    vector<Point2f> approx;

    for (size_t i = 0; i < contours.size(); i++) {
        approxPolyDP(Mat(contours[i]), approx, arcLength(Mat(contours[i]), true)*0.02, true);

        if (fabs(contourArea(Mat(approx))) > 50000){ // 일정 크기 이상의 면적
            int size = approx.size();

            //사각형 검출
            if(size==4){

                //---------------사각형 확인----------------
                //line(img_result, approx[0], approx[1], Scalar(255, 0, 0), 5);
                //line(img_result, approx[1], approx[2], Scalar(0, 255, 0), 5);
                //line(img_result, approx[2], approx[3], Scalar(0, 0, 255), 5);
                //line(img_result, approx[3], approx[0], Scalar(255, 255, 255), 100);

                int fontface = FONT_HERSHEY_SIMPLEX;
                double scale = 2;
                int thickness = 5;
                int baseline = 0;

                Size text = getTextSize(to_string(approx.size()), fontface, scale, thickness, &baseline);
                Rect r = boundingRect(contours[i]);

                Point pt(r.x + ((r.width - text.width) / 2), r.y + ((r.height + text.height) / 2));
                //rectangle(img_result, pt + Point(0, baseline), pt + Point(text.width, -text.height), CV_RGB(200, 200, 200), CV_FILLED);
                //putText(img_result, to_string(approx.size()), pt, fontface, scale, CV_RGB(255, 255, 255), thickness, 8);

                putText(img_result, "0:" + to_string((int)approx[0].x) + " , " + to_string((int)approx[0].y), approx[0], fontface, scale, CV_RGB(255, 255, 255), thickness, 8);
                putText(img_result, "1:" + to_string((int)approx[1].x) + " , " + to_string((int)approx[1].y), approx[1], fontface, scale, CV_RGB(255, 255, 255), thickness, 8);
                putText(img_result, "2:" + to_string((int)approx[2].x) + " , " + to_string((int)approx[2].y), approx[2], fontface, scale, CV_RGB(255, 255, 255), thickness, 8);
                putText(img_result, "3:" + to_string((int)approx[3].x) + " , " + to_string((int)approx[3].y), approx[3], fontface, scale, CV_RGB(255, 255, 255), thickness, 8);

                //----------------사각형 확인----------------------


                //사각형의 네 꼭지점 기준으로 직사각형 복원
                Point p1,p2,p3,p4;
                Point2f src[4], dst[4];
                vector<Point> rect;
                long int d1,d2,d3,d4;

                d1 = sqrt(pow(approx[0].x - approx[1].x,2) + pow(approx[0].y - approx[1].y,2));
                d2 = sqrt(pow(approx[1].x - approx[2].x,2) + pow(approx[1].y - approx[2].y,2));
                d3 = sqrt(pow(approx[2].x - approx[3].x,2) + pow(approx[2].y - approx[3].y,2));
                d4 = sqrt(pow(approx[3].x - approx[0].x,2) + pow(approx[3].y - approx[0].y,2));

                if(d1 < d2 && d1 < d3 && d1 < d4){
                    if(approx[0].x < approx[1].x){ p1 = approx[0]; p2 = approx[1]; p3 = approx[2]; p4 = approx[3]; }
                    else{ p1 = approx[1]; p2 = approx[0]; p3 = approx[3]; p4 = approx[2]; }
                }
                else if(d2 < d1 && d2 < d3 && d2 < d4){
                    if(approx[1].x < approx[2].x){ p1 = approx[1]; p2 = approx[2]; p3 = approx[3]; p4 = approx[0]; }
                    else{ p1 = approx[2]; p2 = approx[1]; p3 = approx[0]; p4 = approx[3]; }
                }
                else if(d3 < d1 && d3 < d2 && d3 < d4){
                    if(approx[2].x < approx[3].x){ p1 = approx[2]; p2 = approx[3]; p3 = approx[0]; p4 = approx[1]; }
                    else{ p1 = approx[3]; p2 = approx[2]; p3 = approx[1]; p4 = approx[0]; }
                }
                else if(d4 < d1 && d4 < d2 && d4 < d3){
                    if(approx[3].x < approx[0].x){ p1 = approx[3]; p2 = approx[0]; p3 = approx[1]; p4 = approx[2]; }
                    else{ p1 = approx[0]; p2 = approx[3]; p3 = approx[2]; p4 = approx[1]; }
                }

                rect.push_back(p1);
                rect.push_back(p2);
                rect.push_back(p3);
                rect.push_back(p4);

                double w1 = sqrt( pow(p3.x - p4.x,2) + pow(p3.x - p4.x,2));
                double w2 = sqrt( pow(p2.x - p1.x,2) + pow(p2.x - p1.x,2));
                double h1 = sqrt( pow(p2.x - p3.x,2) + pow(p2.x - p3.x,2));
                double h2 = sqrt( pow(p1.x - p4.x,2) + pow(p1.x - p4.x,2));
                double maxWidth = (w1 < w2) ? w1 : w2;
                double maxHeight = (h1 < h2) ? h1 : h2;

                src[0] = Point2f(p1.x, p1.y);
                src[1] = Point2f(p2.x, p2.y);
                src[2] = Point2f(p3.x, p3.y);
                src[3] = Point2f(p4.x, p4.y);

                dst[0] = Point2f(0,0);
                dst[1] = Point2f(maxWidth - 1,0);
                dst[2] = Point2f(maxWidth - 1, maxHeight -1);
                dst[3] = Point2f(0, maxHeight -1);

                Mat transformMatrix = getPerspectiveTransform(src, dst);

                warpPerspective(img_input,img_transform, transformMatrix, Size(maxWidth,maxHeight));

                //putText(img_transform, "size t : "+ to_string(img_transform.rows) + " " + to_string(img_transform.cols), Point(100,100), fontface, scale, CV_RGB(255, 255, 255), thickness, 8);
                //putText(img_transform, "size r : "+ to_string(img_result.rows) + " " + to_string(img_result.cols), Point(100,200), fontface, scale, CV_RGB(255, 255, 255), thickness, 8);

                resize(img_transform, img_transform, Size(1526,2948), 0, 0, INTER_LINEAR);
                // 당구대 규격 내경-1422:2844, 쿠션 두께 -52
                // 당구공 규격 61.5
            }
        }

    }
    //img_output=img_transform;

    Mat img_redball = img_transform.clone();
    Mat img_yellowball = img_transform.clone();
    Mat img_whiteball = img_transform.clone();
    Mat img_hsv1,img_hsv2,img_hsv3;
    Mat img_mask2,img_mask3,img_mask4;

    Point pt_red,pt_yellow,pt_white; // 각 공의 좌표

    //빨간 공 좌표 얻기
    cvtColor(img_redball, img_hsv1, COLOR_RGB2HSV);
    inRange(img_hsv1, Scalar(160, 100, 100), Scalar(179, 255, 255), img_mask2);

    erode(img_mask2, img_mask2, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
    dilate(img_mask2, img_mask2, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));

    dilate(img_mask2, img_mask2, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
    erode(img_mask2, img_mask2, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));

    vector<vector<Point>> contours1;
    findContours(img_mask2, contours1, RETR_LIST, CHAIN_APPROX_SIMPLE);
    vector<Point2f> approx1;

    for (size_t i = 0; i < contours1.size(); i++) {
        approxPolyDP(Mat(contours1[i]), approx1, arcLength(Mat(contours1[i]), true)*0.02, true);
        if (fabs(contourArea(Mat(approx1))) > 1000){
            int fontface = FONT_HERSHEY_SIMPLEX;
            double scale = 2;
            int thickness = 5;
            int baseline = 0;

            Size text = getTextSize(to_string(approx1.size()), fontface, scale, thickness, &baseline);
            Rect r = boundingRect(contours1[i]);

            pt_red = Point(r.x + ((r.width - text.width) / 2), r.y + ((r.height + text.height) / 2));

            //putText(img_transform, "red : " + to_string(pt_red.x) + "," + to_string(pt_red.y), pt_red, fontface, scale, CV_RGB(255, 255, 255), thickness, 8);
        }

    }

    //노란 공 좌표 얻기
    cvtColor(img_yellowball, img_hsv2, COLOR_RGB2HSV);
    inRange(img_hsv2, Scalar(18, 100, 100), Scalar(38, 255, 255), img_mask3);

    erode(img_mask3, img_mask3, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
    dilate(img_mask3, img_mask3, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));

    dilate(img_mask3, img_mask3, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
    erode(img_mask3, img_mask3, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));

    vector<vector<Point>> contours2;
    findContours(img_mask3, contours2, RETR_LIST, CHAIN_APPROX_SIMPLE);
    vector<Point2f> approx2;

    for (size_t i = 0; i < contours2.size(); i++) {
        approxPolyDP(Mat(contours2[i]), approx2, arcLength(Mat(contours2[i]), true)*0.02, true);
        if (fabs(contourArea(Mat(approx2))) > 1000){
            int fontface = FONT_HERSHEY_SIMPLEX;
            double scale = 2;
            int thickness = 5;
            int baseline = 0;

            Size text = getTextSize(to_string(approx2.size()), fontface, scale, thickness, &baseline);
            Rect r = boundingRect(contours2[i]);

            pt_yellow = Point(r.x + ((r.width - text.width) / 2), r.y + ((r.height + text.height) / 2));

            //putText(img_transform, "yellow : " + to_string(pt_yellow.x) + "," + to_string(pt_yellow.y), pt_yellow, fontface, scale, CV_RGB(255, 255, 255), thickness, 8);
        }
    }

    //하얀 공 좌표 얻기
    cvtColor(img_whiteball, img_hsv3, COLOR_RGB2HSV);
    inRange(img_hsv3, Scalar(0, 0, 0), Scalar(255, 50, 255), img_mask4);

    erode(img_mask4, img_mask4, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
    dilate(img_mask4, img_mask4, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));

    dilate(img_mask4, img_mask4, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));
    erode(img_mask4, img_mask4, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)));

    vector<vector<Point>> contours3;
    findContours(img_mask4, contours3, RETR_LIST, CHAIN_APPROX_SIMPLE);
    vector<Point2f> approx3;

    for (size_t i = 0; i < contours3.size(); i++) {
        approxPolyDP(Mat(contours3[i]), approx3, arcLength(Mat(contours3[i]), true)*0.02, true);
        if (fabs(contourArea(Mat(approx3))) > 1000){
            int fontface = FONT_HERSHEY_SIMPLEX;
            double scale = 2;
            int thickness = 5;
            int baseline = 0;

            Size text = getTextSize(to_string(approx3.size()), fontface, scale, thickness, &baseline);
            Rect r = boundingRect(contours3[i]);

            pt_white = Point(r.x + ((r.width - text.width) / 2), r.y + ((r.height + text.height) / 2));

            //putText(img_transform, "white : " + to_string(pt_white.x) + "," + to_string(pt_white.y), pt_white, fontface, scale, CV_RGB(255, 255, 255), thickness, 8);
            //putText(img_transform, "white : " + to_string(fabs(contourArea(Mat(approx3)))), pt_white, fontface, scale, CV_RGB(255, 255, 255), thickness, 8);
        }
    }
    //img_output = img_transform;
    //img_output = img_pool;

    int ball_point[6];
    ball_point[0] = pt_red.x - 52;
    ball_point[1] = pt_red.y - 52;
    ball_point[2] = pt_white.x - 52;
    ball_point[3] = pt_white.y - 52;
    ball_point[4] = pt_yellow.x - 52;
    ball_point[5] = pt_yellow.y - 52;

    ball b1;
    ball b2;
    ball b3;

    if(hitball == 1){ // b1이 노랑색
        b1.x = pt_yellow.x - 52;
        b1.y = pt_yellow.y - 52;
        b1.color = 'y';
        b2.x = pt_red.x - 52;
        b2.y = pt_red.y - 52;
        b2.color = 'r';
        b3.x = pt_white.x - 52;
        b3.y = pt_white.y - 52;
        b3.color = 'w';
    }
    else{ // b1이 흰색
        b1.x = pt_white.x - 52;
        b1.y = pt_white.y - 52;
        b1.color = 'w';
        b2.x = pt_red.x - 52;
        b2.y = pt_red.y - 52;
        b2.color = 'r';
        b3.x = pt_yellow.x - 52;
        b3.y = pt_yellow.y - 52;
        b3.color = 'y';
    }

    resize(img_pool, img_pool, Size(1769,3190), 0, 0, INTER_LINEAR);
    resize(img_rb, img_rb, Size(61.5,61.5), 0, 0, INTER_LINEAR);
    resize(img_yb, img_yb, Size(61.5,61.5), 0, 0, INTER_LINEAR);
    resize(img_wb, img_wb, Size(61.5,61.5), 0, 0, INTER_LINEAR);

    int b2x = b2.x+175;
    int b2y = b2.y+173;
    int b1x = b1.x + 175;
    int b1y = b1.y + 173;
    int b3x = b3.x + 175;
    int b3y = b3.y + 173;

    img_pool.copyTo(img_output);
    //putText(img_output, to_string(b1.x) + "," + to_string(b1.y), Point(b1.x,b1.y), FONT_HERSHEY_SIMPLEX, 2, CV_RGB(255, 255, 255), 5, 8);
    //putText(img_output, to_string(b2.x) + "," + to_string(b2.y), Point(b2.x,b2.y), FONT_HERSHEY_SIMPLEX, 2, CV_RGB(255, 255, 255), 5, 8);
    //putText(img_output, to_string(b3.x) + "," + to_string(b3.y), Point(b3.x,b3.y), FONT_HERSHEY_SIMPLEX, 2, CV_RGB(255, 255, 255), 5, 8);
    circle(img_output,Point(b2x,b2y),31, Scalar(204,0,0), -1);
    if(hitball==1){// b1이 노랑
        circle(img_output,Point(b1x,b1y),31, Scalar(255,153,0), -1); //노랑
        circle(img_output,Point(b3x,b3y),31, Scalar(0,0,0),5); //흰색
    }
    else{
        circle(img_output,Point(b1x,b1y),31, Scalar(0,0,0),5); //흰색
        circle(img_output,Point(b3x,b3y),31, Scalar(255,153,0), -1); //노랑
    }
    /*
    int b2x = b2.x + 175;
    int b2y = b2.y + 173;
    //img_pool에 빨간공 겹치기
    img_pool.copyTo(img_output);

    // start at the row indicated by location, or at row 0 if location.y is negative.
    for (int y = std::max(b2y, 0); y < img_pool.rows; ++y) {
        int fY = y - b2y; // because of the translation

        // we are done of we have processed all rows of the foreground image.
        if (fY >= img_rb.rows)
            break;

        // start at the column indicated by location,

        // or at column 0 if location.x is negative.
        for (int x = std::max(b2x, 0); x < img_pool.cols; ++x)
        {
            int fX = x - b2x; // because of the translation.

            // we are done with this row if the column is outside of the foreground image.
            if (fX >= img_rb.cols)
                break;

            // determine the opacity of the foregrond pixel, using its fourth (alpha) channel.
            double opacity =
                    ((double)img_rb.data[fY * img_rb.step + fX * img_rb.channels() + 3])

                    / 255.;


            // and now combine the background and foreground pixel, using the opacity,

            // but only if opacity > 0.
            for (int c = 0; opacity > 0 && c < img_output.channels(); ++c)
            {
                unsigned char foregroundPx =
                        img_rb.data[fY * img_rb.step + fX * img_rb.channels() + c];
                unsigned char backgroundPx =
                        img_pool.data[y * img_pool.step + x * img_pool.channels() + c];
                img_output.data[y*img_output.step + img_output.channels()*x + c] =
                        backgroundPx * (1. - opacity) + foregroundPx * opacity;
            }
        }
    }

    img_pool=img_output.clone();

    int b1x = b1.x + 175;
    int b1y = b1.y + 173;
    int b3x = b3.x + 175;
    int b3y = b3.y + 173;

    if(hitball==1) { // b1==노랑
        //img_pool에 노랑,흰색공 겹치기
        img_pool.copyTo(img_output);
        for (int y = std::max(b1y, 0); y < img_pool.rows; ++y) {
            int fY = y - b1y;
            if (fY >= img_yb.rows) break;
            for (int x = std::max(b1x, 0); x < img_pool.cols; ++x) {
                int fX = x - b1x;
                if (fX >= img_yb.cols) break;

                double opacity = ((double) img_yb.data[fY * img_yb.step + fX * img_yb.channels() + 3]) / 255.;

                for (int c = 0; opacity > 0 && c < img_output.channels(); ++c) {
                    unsigned char foregroundPx = img_yb.data[fY * img_yb.step + fX * img_yb.channels() + c];
                    unsigned char backgroundPx = img_pool.data[y * img_pool.step + x * img_pool.channels() + c];
                    img_output.data[y * img_output.step + img_output.channels() * x + c] = backgroundPx * (1. - opacity) + foregroundPx * opacity;
                }
            }
        }
        img_pool=img_output.clone();
        img_pool.copyTo(img_output);
        for (int y = std::max(b3y, 0); y < img_pool.rows; ++y) {
            int fY = y - b3y;
            if (fY >= img_wb.rows) break;
            for (int x = std::max(b3x, 0); x < img_pool.cols; ++x) {
                int fX = x - b3x;
                if (fX >= img_wb.cols) break;

                double opacity = ((double) img_wb.data[fY * img_wb.step + fX * img_wb.channels() + 3]) / 255.;

                for (int c = 0; opacity > 0 && c < img_output.channels(); ++c) {
                    unsigned char foregroundPx = img_wb.data[fY * img_wb.step + fX * img_wb.channels() + c];
                    unsigned char backgroundPx = img_pool.data[y * img_pool.step + x * img_pool.channels() + c];
                    img_output.data[y * img_output.step + img_output.channels() * x + c] = backgroundPx * (1. - opacity) + foregroundPx * opacity;
                }
            }
        }
    }
    else if(hitball == 2){ // b1==흰색공
        //img_pool에 노랑,흰색공 겹치기
        img_pool.copyTo(img_output);
        for (int y = std::max(b1y, 0); y < img_pool.rows; ++y) {
            int fY = y - b1y;
            if (fY >= img_wb.rows) break;
            for (int x = std::max(b1x, 0); x < img_pool.cols; ++x) {
                int fX = x - b1x;
                if (fX >= img_wb.cols) break;

                double opacity = ((double) img_wb.data[fY * img_wb.step + fX * img_wb.channels() + 3]) / 255.;

                for (int c = 0; opacity > 0 && c < img_output.channels(); ++c) {
                    unsigned char foregroundPx = img_wb.data[fY * img_wb.step + fX * img_wb.channels() + c];
                    unsigned char backgroundPx = img_pool.data[y * img_pool.step + x * img_pool.channels() + c];
                    img_output.data[y * img_output.step + img_output.channels() * x + c] = backgroundPx * (1. - opacity) + foregroundPx * opacity;
                }
            }
        }
        img_pool=img_output.clone();
        img_pool.copyTo(img_output);
        for (int y = std::max(b3y, 0); y < img_pool.rows; ++y) {
            int fY = y - b3y;
            if (fY >= img_yb.rows) break;
            for (int x = std::max(b3x, 0); x < img_pool.cols; ++x) {
                int fX = x - b3x;
                if (fX >= img_yb.cols) break;

                double opacity = ((double) img_yb.data[fY * img_yb.step + fX * img_yb.channels() + 3]) / 255.;

                for (int c = 0; opacity > 0 && c < img_output.channels(); ++c) {
                    unsigned char foregroundPx = img_yb.data[fY * img_yb.step + fX * img_yb.channels() + c];
                    unsigned char backgroundPx = img_pool.data[y * img_pool.step + x * img_pool.channels() + c];
                    img_output.data[y * img_output.step + img_output.channels() * x + c] = backgroundPx * (1. - opacity) + foregroundPx * opacity;
                }
            }
        }
    }
    */

    img_output1 = img_output.clone();
    img_output2 = img_output.clone();
    img_output3 = img_output.clone();
    img_output4 = img_output.clone();
    img_output5 = img_output.clone();
    img_output6 = img_output.clone();
    img_output7 = img_output.clone();
    img_output8 = img_output.clone();
    img_output9 = img_output.clone();

    //-----------------------경로찾기 알고리즘 시작----------------------------
    point start_point, end_point;
    int spin; // 1~2
    bool y_hit, r_hit, w_hit;
    int num_hit_cusion;
    int thickness, pre_thick;

    //변수 초기화
    y_hit = false;
    w_hit = false;
    r_hit = false;
    num_hit_cusion = 0;
    thickness = 0;
    pre_thick = 0;

    find_path[0].x = b1.x;
    find_path[0].y = b1.y;

    //wall_point 설정
    for (int i = 1; i <= 142; i++) {
        wall_point[i-1] = { i * 10,0 };
    }
    for (int i = 143; i <= 426; i++) {
        wall_point[i - 1] = { 1422, (i - 142) * 10 };
    }
    for (int i = 427; i <= 568; i++) {
        wall_point[i - 1] = { (i - 426) * 10,2844 };
    }
    for (int i = 569; i <= 852; i++) {
        wall_point[i - 1] = { 0,(i - 568) * 10 };
    }
    int first_hit_ball;
    //시뮬레이션 진행
    for (int i = 0; i < 852; i++) {
        start_point.x = b1.x;
        start_point.y = b1.y;
        end_point.x = wall_point[i].x;
        end_point.y = wall_point[i].y;

        if (ball_collision(start_point, end_point, b2)) { // start-end point 경로에 b2가 있다.
            //맞은 공 체크
            if (b2.color == 'r') r_hit = true;
            else if (b2.color == 'w') w_hit = true;
            else if (b2.color == 'y') y_hit = true;

            // 두께 저장
            if (thickness != 0) pre_thick = thickness;
            thickness = (int)(61.5 - calcDistance(start_point, end_point, b2));
            find_path[12].x = thickness;
            find_path[12].y = thickness;
            if (thickness >= 58) continue;

            //맞은 위치 계산(새로운 start_point) -> find_path[1] 구하기
            double a = sqrt(pow((float)start_point.x - (float)b2.x, 2) + pow((float)start_point.y - (float)b2.y, 2)) /
                       sqrt(pow((float)start_point.x - (float)end_point.x, 2) + pow((float)start_point.y - (float)end_point.y, 2));
            start_point.x += (int)(a * (end_point.x - start_point.x));
            start_point.y += (int)(a * (end_point.y - start_point.y));
            find_path[1].x = start_point.x;
            find_path[1].y = start_point.y;

            //printf("두께 : %d, 벽좌표 : %d %d, 보정좌표 : %d %d\n", thickness,wall_point[i].x,wall_point[i].y,find_path[1].x,find_path[1].y);

            //각도 = 1.5*두께
            double distance = sqrt(pow(find_path[1].x - wall_point[i].x, 2) + pow(find_path[1].y - wall_point[i].y, 2));
            int add_val = (int)(thickness * (1.5) * (0.01572) * distance);

            //printf("두께 = %d 각도 = %f 더하는 값 = %d", thickness,1.5*thickness,add_val);
            //printf(" --- %d %d", wall_point[i].x,wall_point[i].y);

            //wall point 기준 find_path[2] 구하기
            if (i <= 141) { // 아래 y=0
                if (pre_thick > thickness) { //시계방향
                    if (wall_point[i].x >= add_val) {
                        end_point.x = wall_point[i].x - add_val;
                        end_point.y = wall_point[i].y;
                    }
                    else {
                        end_point.x = 0;
                        end_point.y = add_val - wall_point[i].x;
                    }
                }
                else { // 반시계방향
                    if (wall_point[i].x + add_val <= 1422) {
                        end_point.x = wall_point[i].x + add_val;
                        end_point.y = wall_point[i].y;
                    }
                    else {
                        end_point.x = 1422;
                        end_point.y = add_val - (1422 - wall_point[i].x);
                    }
                }
            }
            else if (i <= 425) { // 오른쪽 x=1422
                if (pre_thick > thickness) { //시계방향
                    if (wall_point[i].y >= add_val) {
                        end_point.x = wall_point[i].x;
                        end_point.y = wall_point[i].y - add_val;
                    }
                    else {
                        end_point.x = 1422 - (add_val - wall_point[i].y);
                        end_point.y = 0;
                    }
                }
                else { // 반시계방향
                    if (wall_point[i].y + add_val <= 2844) {
                        end_point.x = wall_point[i].x;
                        end_point.y = wall_point[i].y + add_val;
                    }
                    else {
                        end_point.x = 1422 - (add_val - (2844 - wall_point[i].y));
                        end_point.y = 2844;
                    }
                }
            }
            else if (i <= 567) { //위 y=2844
                if (pre_thick > thickness) { //시계방향
                    if (wall_point[i].x + add_val <= 1422) {
                        end_point.x = wall_point[i].x + add_val;
                        end_point.y = 2844;
                    }
                    else{
                        end_point.x = 1422;
                        end_point.y = 2844 - (add_val - (1422 - wall_point[i].x));
                    }
                }
                else { // 반시계방향
                    if (wall_point[i].x > add_val) {
                        end_point.x = wall_point[i].x - add_val;
                        end_point.y = 2844;
                    }
                    else {
                        end_point.x = 0;
                        end_point.y = 2844 - (add_val - wall_point[i].x);
                    }
                }
            }
            else{ // 왼쪽 x=0
                if (pre_thick > thickness) { //시계방향
                    if (wall_point[i].y + add_val <= 2844) {
                        end_point.x = 0;
                        end_point.y = wall_point[i].y + add_val;
                    }
                    else {
                        end_point.x = add_val - (2844 - wall_point[i].y);
                        end_point.y = 2844;
                    }
                }
                else { // 반시계방향
                    if (wall_point[i].y >= add_val) {
                        end_point.x = 0;
                        end_point.y = wall_point[i].y - add_val;
                    }
                    else {
                        end_point.x = add_val - wall_point[i].y;
                        end_point.y = 0;
                    }
                }
            }

            find_path[2].x = end_point.x;
            find_path[2].y = end_point.y;

            for (spin = 1; spin <= 3; spin++) { // 1:left, 2:right
                if (spin == 1) {
                    b1.left_spin = 10;
                    b1.right_spin = 0;
                }
                else if(spin == 2){
                    b1.right_spin = 10;
                    b1.left_spin = 0;
                }
                else {
                    b1.left_spin = 0;
                    b1.right_spin = 0;
                }

                for (int j = 1; j <= 7; j++) {
                    find_path[j + 2] = calcPoint(find_path[j],find_path[j+1],b1.left_spin,b1.right_spin);
                    if (b1.left_spin > 0) b1.left_spin -= 2;
                    if (b1.right_spin > 0) b1.right_spin -= 2;
                }

                bool find = false;
                for (int j = 4; j <= 8; j++) {
                    start_point = find_path[j];
                    end_point = find_path[j + 1];
                    if (ball_collision(start_point,end_point,b3)) {
                        find = true;

                        double a = sqrt(pow((float)start_point.x - (float)b3.x, 2) + pow((float)start_point.y - (float)b3.y, 2)) /
                                   sqrt(pow((float)start_point.x - (float)end_point.x, 2) + pow((float)start_point.y - (float)end_point.y, 2));
                        start_point.x += (int)(a * (end_point.x - start_point.x));
                        start_point.y += (int)(a * (end_point.y - start_point.y));

                        find_path[j + 1].x = start_point.x;
                        find_path[j + 1].y = start_point.y;
                        find_path[j + 2].x = -1;
                        find_path[j + 2].y = -1;

                        for (int k = j + 3; k <= 10; k++) {
                            find_path[k].x = 0;
                            find_path[k].y = 0;
                        }
                        break;
                    }
                }

                if (find == true) {
                    if (spin == 1) {
                        find_path[11].x = 2;
                        find_path[11].y = 0;
                    }
                    else if (spin == 2) {
                        find_path[11].x = 1;
                        find_path[11].y = 0;
                    }
                    else {
                        find_path[11].x = 3;
                        find_path[11].y = 0;
                    }
                    if (num_find < 50) {
                        int last;
                        for (int l = 0; l < 13; l++) {
                            finded_path[num_find][l] = find_path[l];
                            if(find_path[l+1].x==-1) last=l;
                        }
                        point p;
                        p.x=b2.x;
                        p.y=b2.y;
                        finded_path[num_find][1] = p;
                        p.x=b3.x;
                        p.y=b3.y;
                        finded_path[num_find][last]=p;
                        num_find++;
                    }
                }
            }

        }



        else if (ball_collision(start_point,end_point,b3)) { // start-end point 경로에 b3가 있다.
            //맞은 공 체크
            if (b3.color == 'r') r_hit = true;
            else if (b3.color == 'w') w_hit = true;
            else if (b3.color == 'y') y_hit = true;

            // 두께 저장
            if (thickness != 0) pre_thick = thickness;
            thickness = (int)(61.5 - calcDistance(start_point, end_point, b3));
            find_path[12].x = thickness;
            find_path[12].y = thickness;
            if (thickness >= 58) continue;

            //맞은 위치 계산(새로운 start_point)
            double a = sqrt(pow((float)start_point.x - (float)b3.x, 2) + pow((float)start_point.y - (float)b3.y, 2)) /
                       sqrt(pow((float)start_point.x - (float)end_point.x, 2) + pow((float)start_point.y - (float)end_point.y, 2));
            start_point.x += (int)(a * (end_point.x - start_point.x));
            start_point.y += (int)(a * (end_point.y - start_point.y));
            find_path[1].x = start_point.x;
            find_path[1].y = start_point.y;

            //printf("두께 : %d, 벽좌표 : %d %d, 보정좌표 : %d %d\n", thickness,wall_point[i].x,wall_point[i].y,find_path[1].x,find_path[1].y);

            //각도 = 1.5*두께
            double distance = sqrt(pow(find_path[1].x - wall_point[i].x, 2) + pow(find_path[1].y - wall_point[i].y, 2));
            int add_val = (int)(thickness * (1.5) * (0.01572) * distance);

            //printf("두께 = %d 각도 = %f 더하는 값 = %d", thickness,1.5*thickness,add_val);
            //printf(" --- %d %d", wall_point[i].x,wall_point[i].y);

            //wall point 기준
            if (i <= 48) { // 아래 y=0
                if (pre_thick > thickness) { //시계방향
                    if (wall_point[i].x >= add_val) {
                        end_point.x = wall_point[i].x - add_val;
                        end_point.y = wall_point[i].y;
                    }
                    else {
                        end_point.x = 0;
                        end_point.y = add_val - wall_point[i].x;
                    }
                }
                else { // 반시계방향
                    if (wall_point[i].x + add_val <= 1422) {
                        end_point.x = wall_point[i].x + add_val;
                        end_point.y = wall_point[i].y;
                    }
                    else {
                        end_point.x = 1422;
                        end_point.y = add_val - (1422 - wall_point[i].x);
                    }
                }
            }
            else if (i <= 143) { // 오른쪽 x=1422
                if (pre_thick > thickness) { //시계방향
                    if (wall_point[i].y >= add_val) {
                        end_point.x = wall_point[i].x;
                        end_point.y = wall_point[i].y - add_val;
                    }
                    else {
                        end_point.x = 1422 - (add_val - wall_point[i].y);
                        end_point.y = 0;
                    }
                }
                else { // 반시계방향
                    if (wall_point[i].y + add_val <= 2844) {
                        end_point.x = wall_point[i].x;
                        end_point.y = wall_point[i].y + add_val;
                    }
                    else {
                        end_point.x = 1422 - (add_val - (2844 - wall_point[i].y));
                        end_point.y = 2844;
                    }
                }
            }
            else if (i <= 191) { //위 y=2844
                if (pre_thick > thickness) { //시계방향
                    if (wall_point[i].x + add_val <= 1422) {
                        end_point.x = wall_point[i].x + add_val;
                        end_point.y = 2844;
                    }
                    else {
                        end_point.x = 1422;
                        end_point.y = 2844 - (add_val - (1422 - wall_point[i].x));
                    }
                }
                else { // 반시계방향
                    if (wall_point[i].x > add_val) {
                        end_point.x = wall_point[i].x - add_val;
                        end_point.y = 2844;
                    }
                    else {
                        end_point.x = 0;
                        end_point.y = 2844 - (add_val - wall_point[i].x);
                    }
                }
            }
            else { // 왼쪽 x=0
                if (pre_thick > thickness) { //시계방향
                    if (wall_point[i].y + add_val <= 2844) {
                        end_point.x = 0;
                        end_point.y = wall_point[i].y + add_val;
                    }
                    else {
                        end_point.x = add_val - (2844 - wall_point[i].y);
                        end_point.y = 2844;
                    }
                }
                else { // 반시계방향
                    if (wall_point[i].y >= add_val) {
                        end_point.x = 0;
                        end_point.y = wall_point[i].y - add_val;
                    }
                    else {
                        end_point.x = add_val - wall_point[i].y;
                        end_point.y = 0;
                    }
                }
            }

            find_path[2].x = end_point.x;
            find_path[2].y = end_point.y;

            for (spin = 1; spin <= 3; spin++) { // 1:left, 2:right
                if (spin == 1) {
                    b1.left_spin = 10;
                    b1.right_spin = 0;
                }
                else if(spin == 2){
                    b1.right_spin = 10;
                    b1.left_spin = 0;
                }
                else {
                    b1.left_spin = 0;
                    b1.right_spin = 0;
                }

                for (int j = 1; j <= 7; j++) {
                    find_path[j + 2] = calcPoint(find_path[j], find_path[j + 1], b1.left_spin, b1.right_spin);
                    if (b1.left_spin > 0) b1.left_spin -= 2;
                    if (b1.right_spin > 0) b1.right_spin -= 2;
                }


                bool find = false;
                for (int j = 4; j <= 8; j++) {
                    start_point = find_path[j];
                    end_point = find_path[j + 1];
                    if (ball_collision(start_point,end_point,b2)) {

                        find = true;

                        double a = sqrt(pow((float)start_point.x - (float)b2.x, 2) + pow((float)start_point.y - (float)b2.y, 2)) /
                                   sqrt(pow((float)start_point.x - (float)end_point.x, 2) + pow((float)start_point.y - (float)end_point.y, 2));
                        start_point.x += (int)(a * (end_point.x - start_point.x));
                        start_point.y += (int)(a * (end_point.y - start_point.y));

                        find_path[j + 1].x = start_point.x;
                        find_path[j + 1].y = start_point.y;
                        find_path[j + 2].x = -1;
                        find_path[j + 2].y = -1;

                        for (int k = j + 3; k <= 10; k++) {
                            find_path[k].x = 0;
                            find_path[k].y = 0;
                        }
                        break;
                    }
                }

                if (find == true) {
                    if (spin == 1) {
                        find_path[11].x = 2;
                        find_path[11].y = 0;
                    }
                    else if (spin == 2) {
                        find_path[11].x = 1;
                        find_path[11].y = 0;
                    }
                    else {
                        find_path[11].x = 3;
                        find_path[11].y = 0;
                    }
                    if (num_find < 50) {
                        int last;
                        for (int l = 0; l < 13; l++) {
                            finded_path[num_find][l] = find_path[l];
                            if(find_path[l+1].x==-1) last=l;
                        }
                        point p;
                        p.x=b3.x;
                        p.y=b3.y;
                        finded_path[num_find][1] = p;
                        p.x=b2.x;
                        p.y=b2.y;
                        finded_path[num_find][last]=p;
                        num_find++;
                    }
                }
            }
        }
    }

    for (int i = 0; i < num_find; i++) {
        int j;
        for (j = 0; j < 12; j++) {
            if (finded_path[i][j + 1].x == -1) {
                break;
            }
        }
        finded_path[i][11].y = j;
    }

    for (int i = 0; i < num_find; i++) {
        int min = finded_path[i][11].y;
        int idx = i, temp;
        for (int j = i + 1; j < num_find; j++) {
            if (finded_path[j][11].y < min) {
                min = finded_path[j][11].y;
                idx = j;
            }
        }

        for (int k = 0; k < 12; k++) {
            temp = finded_path[i][k].x;
            finded_path[i][k].x = finded_path[idx][k].x;
            finded_path[idx][k].x = temp;

            temp = finded_path[i][k].y;
            finded_path[i][k].y = finded_path[idx][k].y;
            finded_path[idx][k].y = temp;
        }
    }

    /*
    printf("%d개의 경로를 찾았습니다.\n\n", num_find);
    for (int i = 0; i < num_find; i++) {
        for (int j = 0; j < 12; j++) {
            printf("%d,%d ", finded_path[i][j].x, finded_path[i][j].y);
        }
        printf("\n\n");
    }
    */
    /*
    double score, min_score = 1000000;
    int min_index;

    //database 좌표값 x,y,xy축 이동 -> 400개의 데이터로 확장
    for (int i = 0; i < 100; i++) {
        for (int j = 0; j < 13; j++) {
            if (database[i][j].x == -1) {
                database[i + 100][j].x = -1;
                database[i + 100][j].y = -1;
                database[i + 200][j].x = -1;
                database[i + 200][j].y = -1;
                database[i + 300][j].x = -1;
                database[i + 300][j].y = -1;
                break;
            }
            database[i + 100][j].x = database[i][j].x;
            database[i + 100][j].y = 2844 - database[i][j].y;

            database[i + 200][j].x = 1422 - database[i][j].x;
            database[i + 200][j].y = database[i][j].y;

            database[i + 300][j].x = 1422 - database[i + 100][j].x;
            database[i + 300][j].y = database[i + 100][j].y;
        }
    }

    //당구공 3개의 배치 유사도가 가장 높은 것 찾음
    for (int i = 0; i < 400; i++) {
        double case1,case2;
        case1 = sqrt(pow(database[i][1].x - b2.x, 2) + pow(database[i][1].y - b2.y, 2)) + sqrt(pow(database[i][2].x - b3.x, 2) + pow(database[i][2].y - b3.y, 2));
        case2 = sqrt(pow(database[i][2].x - b2.x, 2) + pow(database[i][2].y - b2.y, 2)) + sqrt(pow(database[i][1].x - b3.x, 2) + pow(database[i][1].y - b3.y, 2));
        if (case1 < case2) {
            score = sqrt(pow(database[i][0].x - b1.x, 2) + pow(database[i][0].y - b1.y, 2)) + case1;
        }
        else {
            score = sqrt(pow(database[i][0].x - b1.x, 2) + pow(database[i][0].y - b1.y, 2)) + case2;
        }

        if (score < min_score) {
            min_score = score;
            min_index = i;
        }
    }

    //printf("%d %f\n", min_index, min_score);


    //해당 배치의 득점루트와 유사도가 높은 순서대로 정렬
    for (int i = 0; i < num_find; i++) {
        double s = 0;
        for (int j = 0; j < 10; j++) {
            //if()
            s += sqrt(pow(database[min_index][j + 3].x - finded_path[i][j].x,2)+pow(database[min_index][j + 3].y - finded_path[i][j].y,2));
        }
        finded_path[i][11].y = (int)s;
       //printf("%d %d\n", i,finded_path[i][11].y);
    }

    //정렬
    for (int i = 0; i < num_find; i++) {
        int min = finded_path[i][11].y;
        int idx=i,temp;
        for (int j = i + 1; j < num_find; j++) {
            if (finded_path[j][11].y < min) {
                min = finded_path[j][11].y;
                idx = j;
            }
        }

        for (int k = 0; k < 13; k++) {
            temp = finded_path[i][k].x;
            finded_path[i][k].x = finded_path[idx][k].x;
            finded_path[idx][k].x = temp;

            temp = finded_path[i][k].y;
            finded_path[i][k].y = finded_path[idx][k].y;
            finded_path[idx][k].y = temp;
        }
    }
    */
    /*
    printf("\n");
    for (int i = 0; i < num_find; i++) {
        printf("%d %d\n", i, finded_path[i][11].y);
    }
     */

    int len=0;
    for(int i=0;i<10;i++){
        if(finded_path[0][i+1].x == -1) break;
        line(img_output, Point(finded_path[0][i].x + 175,finded_path[0][i].y + 173), Point(finded_path[0][i+1].x + 175,finded_path[0][i+1].y + 173), Scalar(0, 0, 0), 10);
        len++;
    }
    infor[0] = finded_path[0][11].x; // spin
    infor[1] = finded_path[0][12].x; // 두께
    infor[2] = len; // 길이 - 세기

    len=0;
    for(int i=0;i<10;i++){
        if(finded_path[1][i+1].x == -1) break;
        line(img_output1, Point(finded_path[1][i].x + 175,finded_path[1][i].y + 173), Point(finded_path[1][i+1].x + 175,finded_path[1][i+1].y + 173), Scalar(0, 0, 0), 10);
        len++;
    }
    infor[3] = finded_path[1][11].x; // spin
    infor[4] = finded_path[1][12].x; // 두께
    infor[5] = len; // 길이 - 세기

    len=0;
    for(int i=0;i<10;i++){
        if(finded_path[2][i+1].x == -1) break;
        line(img_output2, Point(finded_path[2][i].x + 175,finded_path[2][i].y + 173), Point(finded_path[2][i+1].x + 175,finded_path[2][i+1].y + 173), Scalar(0, 0, 0), 10);
        len++;
    }
    infor[6] = finded_path[2][11].x; // spin
    infor[7] = finded_path[2][12].x; // 두께
    infor[8] = len; // 길이 - 세기

    len=0;
    for(int i=0;i<10;i++){
        if(finded_path[3][i+1].x == -1) break;
        line(img_output3, Point(finded_path[3][i].x + 175,finded_path[3][i].y + 173), Point(finded_path[3][i+1].x + 175,finded_path[3][i+1].y + 173), Scalar(0, 0, 0), 10);
        len++;
    }
    infor[9] = finded_path[3][11].x; // spin
    infor[10] = finded_path[3][12].x; // 두께
    infor[11] = len; // 길이 - 세기

    len=0;
    for(int i=0;i<10;i++){
        if(finded_path[4][i+1].x == -1) break;
        line(img_output4, Point(finded_path[4][i].x + 175,finded_path[4][i].y + 173), Point(finded_path[4][i+1].x + 175,finded_path[4][i+1].y + 173), Scalar(0, 0, 0), 10);
        len++;
    }
    infor[12] = finded_path[4][11].x; // spin
    infor[13] = finded_path[4][12].x; // 두께
    infor[14] = len; // 길이 - 세기

    len=0;
    for(int i=0;i<10;i++){
        if(finded_path[5][i+1].x == -1) break;
        line(img_output5, Point(finded_path[5][i].x + 175,finded_path[5][i].y + 173), Point(finded_path[5][i+1].x + 175,finded_path[5][i+1].y + 173), Scalar(0, 0, 0), 10);
        len++;
    }
    infor[15] = finded_path[5][11].x; // spin
    infor[16] = finded_path[5][12].x; // 두께
    infor[17] = len; // 길이 - 세기

    len=0;
    for(int i=0;i<10;i++){
        if(finded_path[6][i+1].x == -1) break;
        line(img_output6, Point(finded_path[6][i].x + 175,finded_path[6][i].y + 173), Point(finded_path[6][i+1].x + 175,finded_path[6][i+1].y + 173), Scalar(0, 0, 0), 10);
        len++;
    }
    infor[18] = finded_path[6][11].x; // spin
    infor[19] = finded_path[6][12].x; // 두께
    infor[20] = len; // 길이 - 세기

    len=0;
    for(int i=0;i<10;i++){
        if(finded_path[7][i+1].x == -1) break;
        line(img_output7, Point(finded_path[7][i].x + 175,finded_path[7][i].y + 173), Point(finded_path[7][i+1].x + 175,finded_path[7][i+1].y + 173), Scalar(0, 0, 0), 10);
        len++;
    }
    infor[21] = finded_path[7][11].x; // spin
    infor[22] = finded_path[7][12].x; // 두께
    infor[23] = len; // 길이 - 세기

    len=0;
    for(int i=0;i<10;i++){
        if(finded_path[8][i+1].x == -1) break;
        line(img_output8, Point(finded_path[8][i].x + 175,finded_path[8][i].y + 173), Point(finded_path[8][i+1].x + 175,finded_path[8][i+1].y + 173), Scalar(0, 0, 0), 10);
        len++;
    }
    infor[24] = finded_path[8][11].x; // spin
    infor[25] = finded_path[8][12].x; // 두께
    infor[26] = len; // 길이 - 세기

    len=0;
    for(int i=0;i<10;i++){
        if(finded_path[9][i+1].x == -1) break;
        line(img_output9, Point(finded_path[9][i].x + 175,finded_path[9][i].y + 173), Point(finded_path[9][i+1].x + 175,finded_path[9][i+1].y + 173), Scalar(0, 0, 0), 10);
        len++;
    }
    infor[27] = finded_path[9][11].x; // spin
    infor[28] = finded_path[9][12].x; // 두께
    infor[29] = len; // 길이 - 세기

    infor[30] = num_find;

    if((pt_red.x == 0 && pt_red.y ==0 ) || (pt_yellow.x == 0 && pt_yellow.y ==0 ) || (pt_white.x == 0 && pt_white.y ==0 )){
        infor[30] = -1;
    }

    (*env).SetIntArrayRegion(result, 0, 31, infor);

    return result;
}

}